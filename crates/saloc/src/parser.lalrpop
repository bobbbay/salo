//! Parser for the Salo language

use std::str::FromStr;
use crate::ast::{Expr, Ident, Type, Value};

grammar;

//! Main ///

// A Salo program contains 0 or more expressions.
pub Salo: Vec<Expr<'input>> = {
    <Expr*>,
};

// An expression is one of the following:
Expr: Expr<'input> = {
    /// A value by itself
    /// ```salo
    /// true
    /// ```
    <Value> ";" => Expr::Value(<>),

    /// A comment
    /// ```salo
    /// -- It's a comment in a comment. Yes, this
    /// -- goes all the way down.
    /// ```
    r"--[^\n\r]*[\n\r]*" => Expr::Skip(),
    
    /// An untyped assignement
    /// ```salo
    /// x = true;
    /// ```
    <name:Ident> "=" <value:Value> ";" => Expr::Var { name, t: None, value: Some(Box::new(value)) },

    /// A typed assignement
    /// ```salo
    /// x : Bool;
    /// ```
    <name:Ident> ":" <t:TypeName> ";" => Expr::Var { name, t: Some(t), value: None },

    /// A function annotation
    /// ```salo
    /// f : Bool -> Bool -> Bool;
    /// ```
    <name:Ident> ":" <args:(<TypeName> "->")+> <returns:TypeName> ";" => Expr::Value(Value::Fn {
        name,
        args: Some(args),
        value: Some(returns),
        matches: None,
        body: None,
    }),

    /// A function declaration
    /// ```salo
    /// f x y = true
    /// ```
    <name:Ident> <matches:(<Ident>)+> "=" <body:Expr> => Expr::Value(Value::Fn {
        name,
        args: None,
        value: None,
        matches: Some(matches),
        body: Some(Box::new(body)),
    }),
};

Value: Value<'input> = {
    Bool => Value::Bool(<>),
    Num => Value::Num(<>),
    Str => Value::Str(<>),
};

//! Types ///

// true / false
Bool: bool = {
    "true" => true,
    "false" => false,
};

Num: i32 = r"[0-9]+" => i32::from_str(<>).unwrap();

Str: &'input str = r#"".*""#;

// Not specifically a type, but rather the textual representation of types.
TypeName: Type = {
    "Bool" => Type::Bool,
    "Num" => Type::Num,
    "Str" => Type::Str,
};

//! Misc ///
// Any valid identifier
Ident: Ident<'input> = {
    r"[A-Za-z]+" => Ident(<>),
};
