\documentclass[conference]{IEEEtran}

\usepackage{ebproof}
\usepackage{listings}
\usepackage{amssymb}

\usepackage{cite}

\input epsf
\usepackage{graphicx}

\usepackage{url}
\usepackage{amsmath}
\interdisplaylinepenalty=2500

\hyphenation{op-tical net-works semi-conduc-tor IEEEtran}
\begin{document}

\title{\LARGE Declarative platform-agnostic dependently typed build and deployment configuration languages for operating systems}
\author{SEMC, Nexus Aurora}

\maketitle

\begin{abstract}
In the modern computing industry, operating systems are one of the most widely-configured parts of a project. Their management of numerous key computers components - such as  input/output, memory, and packages - makes them a beehive for never-ending configuration. Without a unified system, information about current configuration can be lost over time. New members looking at a deployed OS are very unlikely to catch every modification at first glance, software updates are likely to introduce new configuration requirements, and making even small changes in general can be a complete mess. This paper introduces Salo: a declarative, dependently-typed configuration language that eliminates this issue entirely. With a language such as Salo, changes to configuration are centralized in one set of declarations, solving all of the previously-mentioned issues with operating system maintainership - and more.
\end{abstract}
\IEEEoverridecommandlockouts
\begin{keywords}
Language design, dependent types, configuration languages, type theory.
\end{keywords}

\IEEEpeerreviewmaketitle

\section{Introduction}

TODO: Intro

\section{Language}

\subsection{Syntax}

TODO: Syntax

\subsection{Type System}

\newcommand{\type}{\textrm{Type}}

Naming conventions:

\begin{itemize}
    \item Lowercase Latin letters (e.g. $x$, $y$): variables
    \item Capital Latin letters (e.g. $A$, $B$): types
    \item Capital Greek letters (e.g. $\Gamma$, $\Delta$): contexts
\end{itemize}

\vspace{10pt}

\subsubsection{Zero type}

\[
\begin{prooftree}
    \hypo { }
    \infer1 { \vdash \varnothing : \type }
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo { \Gamma \vdash p : \varnothing, \quad \Gamma \vdash C : \type }
    \infer1 { \Gamma \vdash \textrm{abort}(p) : C }
\end{prooftree}
\]

\subsubsection{Unit type}

\[
\begin{prooftree}
    \hypo { }
    \infer1 { \vdash \textrm{unit} : \type }
\end{prooftree}
, \quad
\begin{prooftree}
    \hypo { }
    \infer1 { \vdash \textrm{()} : \textrm{unit} }
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo { \Gamma \vdash C : \type, \quad \Gamma \vdash c : C, \quad \Gamma \vdash p : \textrm{unit} }
    \infer1 { \Gamma \vdash \textrm{triv}(p, c) : C }
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo { \Gamma \vdash C : \type, \quad \Gamma \vdash c : C }
    \infer1 { \Gamma \vdash \textrm{triv}(\textrm{tt}, c) \equiv c : C }
\end{prooftree}
\]

\subsubsection{Product types}

\[
\begin{prooftree}
    \hypo { \Gamma \vdash A : \type, \quad \Gamma \vdash B : \type }
    \infer1 { \Gamma \vdash A \times B : \type }
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo { \Gamma \vdash a : A, \quad \Gamma \vdash b : B }
    \infer1 { \Gamma \vdash (a, b) : A \times B }
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo { \Gamma \vdash C : \type, 
            \quad \Gamma \vdash p : A \times B,
            \quad \Gamma, x : A, y : B \vdash c : C }
    \infer1 { \Gamma \vdash \textrm{unpack}(p, c) : C }
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo { \Gamma \vdash C : \type, 
            \quad \Gamma \vdash a : A, }
    \infer[no rule]1 {
            \quad \Gamma \vdash b : B,
            \quad \Gamma, x : A, y : B \vdash c : C }
    \infer1 { \Gamma \vdash \textrm{unpack}((a, b), c) \equiv c[a/x, b/y] : C }
\end{prooftree}
\]

\subsubsection{Sum types}

\[
\begin{prooftree}
    \hypo { \Gamma \vdash A : \type, 
            \quad \Gamma \vdash B : \type }
    \infer1 { \Gamma \vdash A + B : \type }
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo { \Gamma \vdash a : A, 
            \quad \Gamma \vdash B : \type }
    \infer1 { \Gamma \vdash \textrm{inl}(a) : A + B }
\end{prooftree}
\quad , \quad
\begin{prooftree}
    \hypo { \Gamma \vdash A : \type,
            \quad \Gamma \vdash b : B }
    \infer1 { \Gamma \vdash \textrm{inr}(b) : A + B }
\end{prooftree}
\]

\vspace{5pt}

\[
\begin{prooftree}
    \hypo { \Gamma \vdash C : \type,
            \quad \Gamma \vdash p : A + B, }
    \infer[no rule]1 {
            \Gamma, x : A \vdash c_A : C,
            \quad \Gamma, y : B \vdash c_B : C }
    \infer1 { \Gamma \vdash \textrm{case}(p, c_A, c_B) : C }
\end{prooftree}
\]

\vspace{5pt}

\[
\begin{prooftree}
    \hypo { \Gamma \vdash C : \type,
            \quad \Gamma \vdash a : A, }
    \infer[no rule]1 {
            \Gamma, x : A \vdash c_A : C,
            \quad \Gamma, y : B \vdash c_B : C }
    \infer1 { \Gamma \vdash \textrm{case}(\textrm{inl}(a), c_A, c_B) \equiv c_A[a/x] : C }
\end{prooftree}
\]

\vspace{5pt}

\[
\begin{prooftree}
    \hypo { \Gamma \vdash C : \type,
            \quad \Gamma \vdash b : B, }
    \infer[no rule]1 {
            \Gamma, x : B \vdash c_A : C,
            \quad \Gamma, y : A \vdash c_B : C }
    \infer1 { \Gamma \vdash \textrm{case}(\textrm{inr}(b), c_A, c_B) \equiv c_A[a/x] : C }
\end{prooftree}
\]

\subsubsection{Anonymous function types}

\[
\begin{prooftree}
    \hypo { \Gamma \vdash A : \type,
            \quad \Gamma \vdash B : \type, }
    \infer1 { \Gamma \vdash A \rightarrow B : \type }
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo { \Gamma, x : A \vdash y : B }
    \infer1 { \Gamma \vdash \lambda(x)(y) : A \rightarrow B }
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo { \Gamma \vdash f : A \rightarrow B,
            \quad \Gamma \vdash a : A }
    \infer1 { \Gamma \vdash f \hspace{3pt} a : B }
\end{prooftree}
\]

\[
\begin{prooftree}
    \hypo { \Gamma, x : A \vdash b : B,
            \quad \Gamma \vdash a : A }
    \infer1 { \Gamma \vdash \lambda(x)(b) a \equiv b[a/x] : B }
\end{prooftree}
\]

\subsection{Standard Library}

TODO: Standard library

\section{Operating System Building}

TODO: Building an OS.

\section{Operating System Deployment}

TODO: Deploying an OS.

\section{Conclusion}

TODO: Conclusion

\section*{Acknowledgment}
\addcontentsline{toc}{section}{Acknowledgment}

TODO: Acknowledgment

\begin{thebibliography}{1}

\bibitem{dolstra} E. Dolstra, M. de Jonge, and E. Visser, \emph{Nix: A Safe and Policy-Free System for Software Deployment}, Utrecht, Netherlands: Utrecht University, November 14-19 2004.

\end{thebibliography}

\end{document}
