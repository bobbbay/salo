#+STARTUP: inlineimages

* Salo MVP

  Welcome to the Salo MVP document. This document outlines what Salo is, what it hopes to accomplish, and what advantages it provides.

** Overview

   In short...

   * Salo is a dependently typed ML-inspired configuration language;
   * Salo provides a modular platform for creating OS-level configurations;
   * With Salo, you can write, build, and deploy your systems with ease.

** Goals

   Salo aims to:

   * Use a static and dependent type system to check code at compile-time;
   * Enable modular configuration;
   * /Extend/ the Nix package manager (not /subsume/ it) to ease mass and remote device management.

** The basics

This section outlines the basics of Salo's syntax. If you'd like to skip this and check out an example instead, scroll down to the [[Example Configuration]].

*** The REPL

   Before starting, let's get familiar with Salo's REPL. Run ~salo~ with no arguments in the command line (once Salo is installed) to open up the prompt:

   #+begin_src salo-repl
   > Welcome to the Salo REPL!
   > 
   #+end_src

   The REPL supports a few commands:

   * ~:t expr~: get the type of ~expr~
   * ~:a expr~: get the generated AST of ~expr~
   * ~:q~: quit

   Now that we're familiar with the REPL, we can continue to learning Salo's configuration language. From this point on, every code block that begins with ~>~ is run in the REPL.

*** Types
 
   Salo's standard library has many types, mostly springing off of Nix's types. These include:

   * Bool
   * Int
   * Nat
   * Str
   * Attrs
   * Array
   * Derivation
   * Function

   Values are created with a (/sometimes/ optional) type signature and value, as such:

   #+begin_src salo
   a : String
   a = "Hello, world!"
   #+end_src

   This is very similar to ML syntax.

   In the example above, the definition of ~a~ could have been rewritten as:

   #+begin_src salo
   a = "Hello, world!"
   #+end_src
  
  Because Salo is smart enough to infer that ~a~'s type is String. More on type inference in the [[Type Inference]] section.

  Unitialized values in Salo are invalid and will throw a compiler error. This means that code like this won't work:

  #+begin_src salo
  b : String
  #+end_src

**** A side note on dependent types

     To better understand how Salo's types work internally, let's examine how they're created in the standard library. Here's the simple declaration for natural numbers in the standard library:

     #+begin_src salo
     type Nat = Z | S Nat
     #+end_src

     Here we see that a natural number can either be ~Z~ - Zero, or ~S Nat~ - a successor to another Nat. For example, =4= is a successor to =3=, which is a successor to =2=, which is a successor to =1=, which is a successor to =0=, which is =Z=.

     This allows us to construct non-primitive types based on anything.

*** Functions

    Functions are defined in a slightly different syntax:

    #+begin_src salo
    > f : String -> String
    > f x = x
    #+end_src

    Very Haskell-esque, indeed! If you're unfamiliar with ML syntax, this defines a function that takes a String and returns a String. In the implementation, ~f~ takes ~x~ and returns ~x~ without modifications.

**** Currying

     Salo's functions curry. Take the following code example (note the REPL prompt):

     #+begin_src salo-repl 
     > :t f
     f : String -> String

     > g : String -> String -> String
     > g x y = x + y

     > :t g
     g : String -> String -> String

     > :t g "Hello, "
     g "Hello, " : String -> String
     #+end_src

     In the beginning, we check the type of =f= (defined above), and see that it's a =String -> String=: straightforward enough. Next, we declare =g= to have a type of =String -> String -> String=, implementing it to take two strings and produces their concatenation. We know that the type of =g= is =String -> String -> String=, but what's cool is that the type of =g "Hello, "= is a =String -> String=!

**** Pattern matching

     Salo supports pattern matching, e.g.:

     #+begin_src 
     name : Bool -> String
     name true = "Bob"
     name false = "Jeffrey"
     #+end_src

     In this case, if the Bool given to ~name~ is true, it will evaluate to "Bob". If it is given false, then it will evaluate to "Jeffrey".

     Salo pattern matches /must/ be exhaustive. Meaning, this won't work:

     #+begin_src salo
     isOne : Int -> Bool
     isOne 1 = true
     #+end_src

     Salo will complain /during compile time/ that this match does not cover every variant. What if we pass on 5, 6, or 7? Salo has no idea what to evaluate to. This, however, will work:

     #+begin_src salo
     isOne : Int -> Bool
     isOne 1 = true
     isOne _ = false
     #+end_src

     With the ~_~ character, Salo can match every other variant. 

**** Generic parameters

     Functions don't have to have strict types - with polymorphism, we're able to allow any type to pass into our program, as long as the function definition is generic enough:

     #+begin_src salo
     genericFunction : a -> a -> a
     genericFunction x y = x + y
     #+end_src

     This means that all of the following function calls are valid:

     #+begin_src salo
     genericFunction 1 1 -- 2
     genericFunction "Foo" "Baz" -- "FooBaz"
     #+end_src
     
*** Imports

    Salo is also able to import other files using the ~import~ keyword. Imports can either bring a library file or a local file into scope. For example:

    #+begin_src 
    import std::prelude::*;
    #+end_src

    Will import everything in the ~prelude~ module of the standard library. This line is actually automatically inserted into every Salo file for ease-of-use. Note that glob imports are not recommended, but are possible.

    #+begin_src 
    import ./emacs.sa::backgroundColor
    #+end_src

    Will search for =./emacs.sa=. If not found, Salo will throw a compile-time error. If found, it will import the ~backgroundColor~ value in emacs.sa. (If this is not found, Salo will again throw a compile-time error.)

    Finally, we have the ability to import the returned value of a file, e.g.

    #+begin_src 
    -- git.sa
    {
      name = "Git",
      version = 1,
    }
    #+end_src

    
    #+begin_src
    -- default.sa
    mygit = import ./git.sa
    #+end_src

    Here, =mygit='s value in =default.sa= is the Attrset defined in =git.sa=.

** Example Configuration

   Combining the syntax defined above, we are able to construct system configuration with Salo:
   
#+begin_src salo
description : String; -- type is string
description = "A system flake for my x86_64 server"; -- set value
-- Note that `description` is not specifically used in the result

-- Type is inferred : Array<Derivation>
packages = [
  pkgs.git -- type is Derivation
];

hardware.pulseaudio = { -- an Attrset
  enable = true; -- Booleans
  extraModules = [ pkgs.pulseaudio-modules-bt ]; -- guess what type this is :P
  package = pkgs.pulseaudioFull;
  support32Bit = true;
  extraConfig = "
    load-module module-bluetooth-policy auto_switch=2
  "; -- multiline Strings also work
}; -- end of Attrset

{
  networking.hostName = "MyServer", -- can inline value

  environment.systemPackages = packages, -- can use variable's value as long as the type checks

  hardware, /* desugars into `hardware = hardware`
               hardware is an Attrset which contains 
               Attrset, `pulseaudio`. */
} -- Note that the semicolon is omitted here, because this is what will be returned
  -- If we placed a semicolon here, Salo would complain that nothing is returned
#+end_src

Evaluates to:

#+begin_src nix
{ config, pkgs, ... }:

{
  networking.hostName = "MyServer";
  environment.systemPackages = [ pkgs.git ];
  hardware.pulseaudio = {
    enable = true;
    extraModules = [ pkgs.pulseaudio-modules-bt ];
    package = pkgs.pulseaudioFull;
    support32Bit = true;
    extraConfig = "load-module module-bluetooth-policy auto_switch=2";
  };
}
#+end_src
** Dependent Types

   Salo's dependently typed system allows the language's types to be expressive. A simple example of enforcing a program with dependent types is the standard library function that adds Vecs. In a non-dependently typed language, we could define the type signature like so:

   #+begin_src salo 
   addVec : Vec -> Vec -> Vec;
   #+end_src

   However, this doesn't really enforce much. In fact, we have no gaurantees from the type signature alone that this function /really/ adds Vecs. Dependent programmers have trust issues.

   We can solve this like so:

   #+begin_src salo 
   addVec : Vec n a -> Vec m a -> Vec (m + n) a;
   #+end_src

   In this case, ~n~ is the length of the first Vec, ~m~ is the length of the second Vec, and ~a~ is the type of both Vecs. Thanks to the type signature by itself, we know that ~addVec~ /must/ return a Vec that - most importantly - has a length of both the Vecs combined. Makes sense!
   
** Deployment

   Salo offers an incremental deployment suite native to the toolset. This allows users to define remote configurations and deploy with ease.

   Deployment in Salo is /incremental/. This means that, during the deployment of an operating system, it will only send the files that have /changed/ - not the whole OS itself. However, Salo also markets itself as stateless - hence, it cannot store a state file of which programs are installed on the remote machine on the local machine. To work around this, Salo makes two requests to remote machines - the first during the apply stage, and the second during the deploy stage.

*** The apply stage

    Salo's apply stage generally takes three steps:

    - Receive the system Attrset;
    - Send a request to the remote server, asking for a diff of programs;
    - Prints out the diff of programs to the user.

    Once Salo knows which files are /already/ on the remote machine, it is able to decide which ones it needs to deploy, which it pipes onto the deploy stage.

*** The deploy stage

    The deploy stage receives a list of programs it needs to compile, and takes two steps:

    - Compile the programs, producing binaries and library files as needed;
    - Sends these files via a remote connection to the remote machine.

*** Defining a remote configuration

    Up until now, it's all been theory. Let's write a configuration that deploys to a remote machine, via ~ssh~.

    #+begin_src salo
    remote = ssh://ip.address.of.machine -- 1.
    packages = with pkgs; [ git ];

    {
      packages,
      remote,
    }
    #+end_src

    1. Note that here we use a special type, ~ssh~, to indicate the location of the remote host. This implements the ~Protocol~ type class, which enables scalability for more protocls added in the future.

    Running ~salo apply <file>~ will check for a connection with the remote host, and go through each stesp as outlined in [[The apply stage]]. If successful, ~salo deploy <file>~ it will continue to deploy in [[The deploy stage]]. Note that ~salo deploy~ will secretly run ~salo apply~ if not applied already.

    Here is a technical outline of remote deployment in Salo:

    #+ATTR_ORG: :width 900
    [[./remote-diagram.png]]

** TODOS

   This document is very much a work-in-progress! Here is a list of what's left to fill in:

   * The module system
   * Type classes (traits)
   * Type inference
   * Literate programming (org-mode)
