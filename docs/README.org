#+STARTUP: inlineimages

* Salo MVP

  Welcome to the Salo MVP document. This document outlines what Salo is, what it hopes to accomplish, and what advantages it provides.

** Overview

   In short...

   * Salo is a static and dependently typed ML-inspired configuration language;
   * Salo provides a modular platform for creating and deploying OS-level configurations.

** Goals

   Salo aims to:

   * Enable modular, OS-level configuration for multiple Linux distributions;
   * Use a static and dependent type system to check code at compile-time.

** Components

   Salo comes in two components: the compiler, which evaluates the Salo language, and the tool, which takes the compiler's output and puts it to use.

   The compiler outputs ~.sam~ /(SAlo Metadata)/ files, which is the evaluated value of the inputted file. The tool takes ~.sam~ files, builds them (into ~.iso~ or ~.sar~), and (optionally) deploys them. 

** The Salo language

This section outlines the basics of Salo's syntax. If you'd like to skip this and check out an example instead, scroll down to the [[Example Configuration]].

*** The REPL

   Before starting, let's get familiar with Salo's REPL. Run ~salo~ with no arguments in the command line (once Salo is installed) to open up the prompt:

   #+begin_src salo-repl
   > Welcome to the Salo REPL!
   > 
   #+end_src

   The REPL supports a few commands:

   * ~:t expr~: get the type of ~expr~
   * ~:a expr~: get the generated AST of ~expr~
   * ~:q~: quit

   Run ~:h~ for more information. 

   Now that we're familiar with the REPL, we can continue to learning Salo's configuration language. From this point on, every code block that begins with ~>~ is run in the REPL.

*** Types
 
   Salo has two primitive types: ~Int~ and ~Str~. More types are defined in the standard library, such as:

   * Bool
   * Nat
   * Array
   * Derivation

   Values are created with a (/sometimes/ optional) type signature and value, as such:

   #+begin_src salo
   a : String;
   a = "Hello, world!";
   #+end_src

   This is very similar to ML syntax.

   In the example above, the definition of ~a~ could have been rewritten as:

   #+begin_src salo
   a = "Hello, world!";
   #+end_src
  
  Because Salo is smart enough to infer that ~a~'s type is String. More on type inference in the [[Type Inference]] section.

  Unitialized values in Salo are invalid and will throw a compiler error. This means that code like this won't work:

  #+begin_src salo
  b : String;
  -- What is b's value?
  #+end_src

  However, Salo is ok with delegating assignment until later on, as long as that value is not used:

  #+begin_src salo
  b : String;
  x : String;
  x = "Goodbye, world!";
  b = "Hello, world!";
  #+end_src

**** A side note on dependent types

     Salo has so little primitives thanks to it's dependent types. To better understand how these work internally, let's examine how they're put to use in the standard library. Here's the simple declaration for natural numbers:

     #+begin_src salo
     type Nat = Z | S Nat;
     #+end_src

     Here we see that a natural number can either be ~Z~ - Zero, or ~S Nat~ - a successor to another Nat. For example, =4= is a successor to =3=, which is a successor to =2=, which is a successor to =1=, which is a successor to =0=, which is =Z=.

     This allows users to construct non-primitive types that are as expressive as the language itself. For more information on expressive types, check out the [[Dependent Types]] chapter.

*** Functions

    Functions are defined in a slightly similar syntax:

    #+begin_src salo
    > f : String -> String;
    > f x = x;
    #+end_src

    If you're unfamiliar with ML syntax, this defines a function that takes a String and returns a String. In the implementation, ~f~ takes ~x~ and returns ~x~ without modifications.

**** Currying

     Salo's functions curry. Take the following code example (note the REPL prompt):

     #+begin_src salo-repl 
     > :t f;
     f : String -> String

     > g : String -> String -> String;
     > g x y = x + y;

     > :t g;
     g : String -> String -> String

     > :t g "Hello, ";
     g "Hello, " : String -> String
     #+end_src

     In the beginning, we check the type of =f= (defined above), and see that it's a =String -> String=: straightforward enough. Next, we declare =g= to have a type of =String -> String -> String=, implementing it to take two strings and produces their concatenation. We know that the type of =g= is =String -> String -> String=, but what's cool is that the type of =g "Hello, "= is a =String -> String=!

**** Pattern matching

     Salo supports pattern matching, e.g.:

     #+begin_src 
     name : Bool -> String
     name true = "Bob"
     name false = "Jeffrey"
     #+end_src

     In this case, if the Bool given to ~name~ is true, it will evaluate to "Bob". If it is given false, then it will evaluate to "Jeffrey".

     Salo pattern matches /must/ be exhaustive. This means that the following won't work:

     #+begin_src salo
     isOne : Int -> Bool
     isOne 1 = true
     #+end_src

     Salo will complain /during compile time/ that this match does not cover every variant. What if we pass on 5, 6, or 7? Salo has no idea what to evaluate to. This, however, will work:

     #+begin_src salo
     isOne : Int -> Bool
     isOne 1 = true
     isOne _ = false
     #+end_src

     With the ~_~ character, Salo can match every other variant.

**** Polymorphic arguments

     Functions don't have to have strict types - with polymorphism, we're able to allow any type to pass into our program, as long as the function definition is "generic" enough:

     #+begin_src salo
     genericAdder : a -> a -> a
     genericAdder x y = x + y
     #+end_src

     This means that all of the following function calls are valid:

     #+begin_src salo
     genericAdder 1 1         --> 2
     genericAdder "Foo" "Baz" --> "FooBaz"
     #+end_src

*** Imports

    Salo is also able to import other files using the ~import~ keyword. Imports can either bring a library file or a local file into scope. For example:

    #+begin_src 
    import std::prelude::*;
    #+end_src

    Will evaluate and bring everything in the ~prelude~ module of the standard library into scope. This line is actually automatically inserted into the beginning of every Salo file. Note that glob imports are not recommended, but are possible.

    #+begin_src 
    import ./emacs.sa::backgroundColor
    #+end_src

    Will search for =./emacs.sa=. If not found, Salo will throw a compile-time error. If found, it will import the ~backgroundColor~ value in emacs.sa. (If this is not found, Salo will again throw a compile-time error.)

    Finally, we have the ability to import the returned value of a file, e.g.

    #+begin_src 
    -- git.sa
    {
      name = "Git",
      version = 1,
    }
    #+end_src
    
    #+begin_src
    -- default.sa
    mygit = import ./git.sa
    #+end_src

    Here, =mygit='s value in =default.sa= is the Attrset defined in =git.sa=.

** Example Configuration

   Combining the syntax defined above, we are able to construct system configuration with Salo:
   
#+begin_src salo
use std::pkgs; -- 1

description : String; -- 2
description = "A system flake for my x86_64 server";

packages : Vec pkgs _; -- 3, 4
packages = [
  pkgs.git
];

main = system: { -- 5
  description, -- 6
  networking.hostName = "MyServer",
  packages,
};

return main; -- 7
#+end_src

 1. We bring all distro-agnostic ~pkgs~ into scope
 2. We declare ~description~ to have a type of ~String~ (this could also be inferred)
 3. ~packages~ has a type of ~Vec~, which is from the standard prelude (~std::prelude~)
 4. ~Vec pkgs _~ means that the Vec contains an inferred amount of ~pkgs~ (which are ~std::sys::ubuntu20::pkgs~)
 5. ~main~ is a system derivation that contains the description, packages, and a hostname of "MyServer"
 6. ~description,~ is the same as ~description = description~
 7. We return ~main~ as the result of this file

** Dependent Types

   Salo's dependently typed system allows the language's types to be expressive. A simple example of enforcing a program with dependent types is the standard library function that adds Vecs. In a non-dependently typed language, we could define the type signature like so:

   #+begin_src salo 
   addVec : Vec -> Vec -> Vec;
   #+end_src

   However, this doesn't really enforce much. In fact, we have no gaurantees from the type signature alone that this function /really/ adds Vecs. Dependent programmers have trust issues.

   We can solve this like so:

   #+begin_src salo 
   addVec : Vec n a -> Vec m a -> Vec (m + n) a;
   #+end_src

   In this case, ~n~ is the length of the first Vec, ~m~ is the length of the second Vec, and ~a~ is the type of both Vecs. Thanks to the type signature by itself, we know that ~addVec~ /must/ return a Vec that - most importantly - has a length of both the Vecs combined. Makes sense!
   
** Deployment

   Salo offers an incremental deployment suite native to the toolset. This allows users to define remote configurations and deploy with ease.

   Deployment in Salo is /incremental/. This means that, during the deployment of an operating system, it will only send the files that have /changed/ - not the whole OS itself. However, Salo also markets itself as stateless - hence, it cannot store a state file of which programs are installed on the remote machine on the local machine. To work around this, Salo makes two requests to remote machines - the first during the apply stage, and the second during the deploy stage.

*** The Apply Stage

    Salo's apply stage generally takes three steps:

    - Receive the system Attrset;
    - Send a request to the remote server, asking for a diff of programs;
    - Prints out the diff of programs to the user.

    Once Salo knows which files are /already/ on the remote machine, it is able to decide which ones it needs to deploy, which it pipes onto the deploy stage.

*** The Deploy Stage

    The deploy stage receives a list of programs it needs to compile, and takes two steps:

    - Compile the programs, producing binaries and library files as needed;
    - Sends these files via a remote connection to the remote machine.

*** Defining a Remote Configuration

    Up until now, it's all been theory. Let's write a configuration that deploys to a remote machine, via ~ssh~.

    #+begin_src salo
    remote = ssh://ip.address.of.machine -- 1.
    packages = with pkgs; [ git ];

    {
      packages,
      remote,
    }
    #+end_src

    1. Note that here we use a special type, ~ssh~, to indicate the location of the remote host. This implements the ~Protocol~ type class, which enables scalability for more protocls added in the future.

    Running ~salo apply <file>~ will check for a connection with the remote host, and go through each stesp as outlined in [[The apply stage]]. If successful, ~salo deploy <file>~ it will continue to deploy in [[The deploy stage]]. Note that ~salo deploy~ will secretly run ~salo apply~ if not applied already.

    Here is a technical outline of remote deployment in Salo:

    #+ATTR_ORG: :width 900
    [[./remote-diagram.png]]

** Rust implementation internals

   The Rust implementation uses typestates to specify a strict pipeline. There are three states, each with its own content:

   * ~Source~
     * ~Filename~: the name of the file, or ~<stdin>~
     * ~Code~: the code content
   * ~AST~
     * ~Tree~: the Abstract Syntax Tree
   * ~Metadata~
     * ~Sam~: the generated SAlo Metadata content
     * ~Nix~: the generated NixOS expression

   There is also an ~Error~ state (containing ~line~, ~start~, ~end~, ~message~, and an optional ~suggestion~), that will be returned when one of the steps encounters an issue. 

** TODOS

   This document is very much a work-in-progress! Here is a list of what's left to fill in:

   * The module system: Salo provides a modular system for enabling/disabling specific configurations
   * Type classes (traits): Grouping types by classes, enabling polymorphism
   * Type inference
   * Literate programming (org-mode): Salo enables programming side-by-side with org-mode content
   * Notation: stricter, macros alternative
